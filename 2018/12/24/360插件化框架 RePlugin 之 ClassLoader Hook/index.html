<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="360插件化框架 RePlugin 之 ClassLoader Hook前言工作原因，最近在研究 RePlugin 。RePlugin 是360手机卫士团队开发的占坑类插件化框架。近几年 Android 插件化非常火，各公司都有不同的插件化方案。这些插件化框架都难免修改系统的 API 来实现一些特性，多处修改系统的 API 带来了一定的风险。如果 Android 系统升级之后有改动，那么插件化框架">
<meta property="og:type" content="article">
<meta property="og:title" content="360插件化框架 RePlugin 之 ClassLoader Hook">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2018&#x2F;12&#x2F;24&#x2F;360%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%20RePlugin%20%E4%B9%8B%20ClassLoader%20Hook&#x2F;index.html">
<meta property="og:site_name" content="九点下班">
<meta property="og:description" content="360插件化框架 RePlugin 之 ClassLoader Hook前言工作原因，最近在研究 RePlugin 。RePlugin 是360手机卫士团队开发的占坑类插件化框架。近几年 Android 插件化非常火，各公司都有不同的插件化方案。这些插件化框架都难免修改系统的 API 来实现一些特性，多处修改系统的 API 带来了一定的风险。如果 Android 系统升级之后有改动，那么插件化框架">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-10-22T13:38:11.533Z">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>360插件化框架 RePlugin 之 ClassLoader Hook</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/projects_url">项目</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2018/12/29/%E6%8B%BE%E5%85%892018/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2018/12/21/%E5%9F%BA%E4%BA%8EReactNative%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2018/12/24/360%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%20RePlugin%20%E4%B9%8B%20ClassLoader%20Hook/" target="_blank" rel="noopener"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2018/12/24/360%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%20RePlugin%20%E4%B9%8B%20ClassLoader%20Hook/&text=360插件化框架 RePlugin 之 ClassLoader Hook" target="_blank" rel="noopener"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2018/12/24/360%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%20RePlugin%20%E4%B9%8B%20ClassLoader%20Hook/&title=360插件化框架 RePlugin 之 ClassLoader Hook" target="_blank" rel="noopener"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2018/12/24/360%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%20RePlugin%20%E4%B9%8B%20ClassLoader%20Hook/&is_video=false&description=360插件化框架 RePlugin 之 ClassLoader Hook" target="_blank" rel="noopener"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=360插件化框架 RePlugin 之 ClassLoader Hook&body=Check out this article: http://yoursite.com/2018/12/24/360%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%20RePlugin%20%E4%B9%8B%20ClassLoader%20Hook/" target="_blank" rel="noopener"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2018/12/24/360%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%20RePlugin%20%E4%B9%8B%20ClassLoader%20Hook/&title=360插件化框架 RePlugin 之 ClassLoader Hook" target="_blank" rel="noopener"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2018/12/24/360%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%20RePlugin%20%E4%B9%8B%20ClassLoader%20Hook/&title=360插件化框架 RePlugin 之 ClassLoader Hook" target="_blank" rel="noopener"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2018/12/24/360%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%20RePlugin%20%E4%B9%8B%20ClassLoader%20Hook/&title=360插件化框架 RePlugin 之 ClassLoader Hook" target="_blank" rel="noopener"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2018/12/24/360%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%20RePlugin%20%E4%B9%8B%20ClassLoader%20Hook/&title=360插件化框架 RePlugin 之 ClassLoader Hook" target="_blank" rel="noopener"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2018/12/24/360%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%20RePlugin%20%E4%B9%8B%20ClassLoader%20Hook/&name=360插件化框架 RePlugin 之 ClassLoader Hook&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#360插件化框架-RePlugin-之-ClassLoader-Hook"><span class="toc-number">1.</span> <span class="toc-text">360插件化框架 RePlugin 之 ClassLoader Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言"><span class="toc-number">1.0.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是ClassLoader"><span class="toc-number">1.0.2.</span> <span class="toc-text">什么是ClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双亲委托模型"><span class="toc-number">1.0.3.</span> <span class="toc-text">双亲委托模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RePlugin是如何Hook-ClassLoader的"><span class="toc-number">1.0.4.</span> <span class="toc-text">RePlugin是如何Hook ClassLoader的</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        360插件化框架 RePlugin 之 ClassLoader Hook
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">九点下班</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2018-12-24T12:21:00.000Z" itemprop="datePublished">2018-12-24</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="360插件化框架-RePlugin-之-ClassLoader-Hook"><a href="#360插件化框架-RePlugin-之-ClassLoader-Hook" class="headerlink" title="360插件化框架 RePlugin 之 ClassLoader Hook"></a>360插件化框架 RePlugin 之 ClassLoader Hook</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>工作原因，最近在研究 <a href="https://github.com/Qihoo360/RePlugin/" target="_blank" rel="noopener">RePlugin</a> 。RePlugin 是360手机卫士团队开发的占坑类插件化框架。<br>近几年 Android 插件化非常火，各公司都有不同的插件化方案。这些插件化框架都难免修改系统的 API 来实现一些特性，多处修改系统的 API 带来了一定的风险。如果 Android 系统升级之后有改动，那么插件化框架就有可能面临不可用的状态。尤其是在 Google 明确表示从 Android9.0 之后将会逐步禁用非官方 API。总之插件化带来了很多的好处，同时也存在一定的风险。RePlugin 的强大之处在于，它只 Hook 了一处系统 API，那就是 ClassLoader。关于 RePlugin 可能会写一系列的文章，但是不会以系统的整个流程这种宏观的方式去写，会从某一个角度出发在源码的基础上进行分析，同时给出合适的 Demo。下面就开始本篇的正题，分享一下 RePlugin 是如何 Hook ClassLoader 的。</p>
<h3 id="什么是ClassLoader"><a href="#什么是ClassLoader" class="headerlink" title="什么是ClassLoader"></a>什么是ClassLoader</h3><p>ClassLoader 按字面意思就是类加载器。Android 应用程序的运行是基于虚拟机的，我们在写代码的时候所有的类文件（.java），在编译阶段都会编译成二进制文件（.class）。在 Android 打包成 apk 的过程中 class 文件会打包到 dex 里。Android 的虚拟机执行的就是 dex 文件。在程序运行过程中，当我们需要 new 一个对象的时候，虚拟机首先需要加载这个对象所对应的 class，加载 class 就是由 ClassLoader 来做的。在 Android 系统中我们常用的 ClassLoader 有两种，一种是 PathClassLoader 另一种是 DexClassLoader，它们都是继承自 BaseDexClassLoader。我们都知道 PathClassLoader 只能加载我们安装过的 apk，DexClassLoader 可以加载 sd 卡上的 apk。那么为什么 DexClassLoader 可以加载 sd 卡上的 apk 呢？</p>
<p>我们分别来看一下 PathClassLoader 和 DexClassLoader 的源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class PathClassLoader extends BaseDexClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    public PathClassLoader(String dexPath, ClassLoader parent) &#123;</span><br><span class="line">        super(dexPath, null, null, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PathClassLoader(String dexPath, String libraryPath,</span><br><span class="line">            ClassLoader parent) &#123;</span><br><span class="line">        super(dexPath, null, libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DexClassLoader extends BaseDexClassLoader &#123;</span><br><span class="line">    public DexClassLoader(String dexPath, String optimizedDirectory,</span><br><span class="line">            String libraryPath, ClassLoader parent) &#123;</span><br><span class="line">        super(dexPath, new File(optimizedDirectory), libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BaseDexClassLoader extends ClassLoader &#123;</span><br><span class="line">    private final DexPathList pathList;</span><br><span class="line"></span><br><span class="line">    public BaseDexClassLoader(String dexPath, File optimizedDirectory,</span><br><span class="line">            String libraryPath, ClassLoader parent) &#123;</span><br><span class="line">        super(parent);</span><br><span class="line">        this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是 PathClassLoader 和 DexClassLoader 的构造方法。它们的主要不同之处就在于 optimizedDirectory 这个参数，PathClassLoader 的 optimizedDirectory 是 null，DexClassLoader 可以接受一个我们自己定义的路径，接下来再看这个参数是在哪使用的。DexPathList 的构造方法接收了这个参数，然后又把它传到了 makeDexElements 中，在 makeDexElements 中 loadDexFile 又接收了这个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">DexPathList.java</span><br><span class="line"></span><br><span class="line">public DexPathList(ClassLoader definingContext, String dexPath,</span><br><span class="line">            String libraryPath, File optimizedDirectory) &#123;</span><br><span class="line">        this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Element[] makeDexElements(ArrayList&lt;File&gt; files,</span><br><span class="line">            File optimizedDirectory) &#123;</span><br><span class="line">        ArrayList&lt;Element&gt; elements = new ArrayList&lt;Element&gt;();</span><br><span class="line">        for (File file : files) &#123;</span><br><span class="line">            ZipFile zip = null;</span><br><span class="line">            DexFile dex = null;</span><br><span class="line">            String name = file.getName();</span><br><span class="line">            if (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">                dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">            &#125; else if (name.endsWith(APK_SUFFIX) || name.endsWith(JAR_SUFFIX)</span><br><span class="line">                    || name.endsWith(ZIP_SUFFIX)) &#123;</span><br><span class="line">                zip = new ZipFile(file);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if ((zip != null) || (dex != null)) &#123;</span><br><span class="line">                elements.add(new Element(file, zip, dex));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return elements.toArray(new Element[elements.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static DexFile loadDexFile(File file, File optimizedDirectory)</span><br><span class="line">            throws IOException &#123;</span><br><span class="line">            //主要的区别就在这里，PathClassLoader 的 optimizedDirectory 一定是 null</span><br><span class="line">        if (optimizedDirectory == null) &#123;</span><br><span class="line">            return new DexFile(file);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            String optimizedPath = optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">            return DexFile.loadDex(file.getPath(), optimizedPath, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String optimizedPathFor(File path,</span><br><span class="line">            File optimizedDirectory) &#123;</span><br><span class="line">        String fileName = path.getName();</span><br><span class="line">        if (!fileName.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">            int lastDot = fileName.lastIndexOf(&quot;.&quot;);</span><br><span class="line">            if (lastDot &lt; 0) &#123;</span><br><span class="line">                fileName += DEX_SUFFIX;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                StringBuilder sb = new StringBuilder(lastDot + 4);</span><br><span class="line">                sb.append(fileName, 0, lastDot);</span><br><span class="line">                sb.append(DEX_SUFFIX);</span><br><span class="line">                fileName = sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        File result = new File(optimizedDirectory, fileName);</span><br><span class="line">        return result.getPath();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>optimizedDirectory 是用来缓存我们需要加载的 dex 文件的，并创建一个 DexFile 对象，如果它为null，那么会直接使用dex文件原有的路径来创建 DexFile 对象。</p>
<p>optimizedDirectory 必须是一个内部存储路径，无论哪种动态加载，加载的可执行文件一定要存放在内部存储。DexClassLoader 可以指定自己的 optimizedDirectory，所以它可以加载外部的 dex，因为这个 dex 会被复制到内部路径的 optimizedDirectory；而 PathClassLoader 没有 optimizedDirectory，所以它只能加载内部的 dex，就是在系统中已经安装过的 apk 里面的。我们再来看一下为什么可执行文件一定要放在内部存储，直接上 DexFile 的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DexFile.java</span><br><span class="line"> private DexFile(String sourceName, String outputName, int flags) throws IOException &#123;</span><br><span class="line">        if (outputName != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                String parent = new File(outputName).getParent();</span><br><span class="line">                if (Libcore.os.getuid() != Libcore.os.stat(parent).st_uid) &#123;</span><br><span class="line">                    throw new IllegalArgumentException(&quot;Optimized data directory &quot; + parent</span><br><span class="line">                            + &quot; is not owned by the current user. Shared storage cannot protect&quot;</span><br><span class="line">                            + &quot; your application from code injection attacks.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ErrnoException ignored) &#123;</span><br><span class="line">                // assume we&apos;ll fail with a more contextual error later</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCookie = openDexFile(sourceName, outputName, flags);</span><br><span class="line">        mFileName = sourceName;</span><br><span class="line">        guard.open(&quot;close&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码我们可以看到，当 outputName!=null 的时候，如果传入的是一个 sd 卡的路径会抛出一个 IllegalArgumentException 异常，表示传入的目录不属于当前用户，sd 卡是共享的目录，有可能引起注入攻击。</p>
<p>以上就是 DexClassLoader 和 PathClassLoader 的区别。</p>
<h3 id="双亲委托模型"><a href="#双亲委托模型" class="headerlink" title="双亲委托模型"></a>双亲委托模型</h3><p>通过 ClassLoader 的构造方法我们可以看到，当我们要实例化一个 ClassLoader 时必须传入一个parent classloader 参数，这样 ClassLoader 之间就有了依赖关系。当类加载器要加载某个类时，首先将加载任务委托给父类加载器。如果父类加载器可以加载这个类，就成功返回。当父类加载器无法加载这个类时，才自己去加载。RePlugin 之所以能通过 Hook ClassLoader 来实现插件的加载就是它打破了原有的双亲委托模型。在加载类时先从插件中去加载，当插件无法加载时再从宿主加载。</p>
<h3 id="RePlugin是如何Hook-ClassLoader的"><a href="#RePlugin是如何Hook-ClassLoader的" class="headerlink" title="RePlugin是如何Hook ClassLoader的"></a>RePlugin是如何Hook ClassLoader的</h3><p>在集成 RePlugin 时，Application 需要继承 RePluginApplication，我们看一下 RePluginApplication 的 attachBaseContext 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line"> protected void attachBaseContext(Context base) &#123;</span><br><span class="line">     super.attachBaseContext(base);</span><br><span class="line">...</span><br><span class="line">     RePlugin.App.attachBaseContext(this, c);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>关键的代码就是 RePlugin.App.attachBaseContext(this, c) 我们进去看一下它具体做了什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void attachBaseContext(Application app, RePluginConfig config) &#123;</span><br><span class="line"></span><br><span class="line">			...省略了大部分代码，其中主要是关于UI进程和常驻进程的一些初始化工作</span><br><span class="line">			</span><br><span class="line">            PMF.init(app);</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>只看我们关心的 Hook ClassLoader 的地方，其他的关于进程初始化的代码以后再做分析。在 attachBaseContext 方法中有调用了 PMF.init(app) 在 init 方法里又调用了 PatchClassLoaderUtils.patch(application) 这就是 Hook ClassLoader 的地方，再进去看一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> public static final void init(Application application) &#123;</span><br><span class="line">     setApplicationContext(application);</span><br><span class="line">...</span><br><span class="line">     PatchClassLoaderUtils.patch(application);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static boolean patch(Application application) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        // 获取原始的classloader</span><br><span class="line">        ClassLoader oClassLoader = (ClassLoader) ReflectUtils.readField(oPackageInfo, &quot;mClassLoader&quot;);</span><br><span class="line">        </span><br><span class="line">        // 创建RePluginClassLoader类，就是我们要替换的classloader</span><br><span class="line">        ClassLoader cl = RePlugin.getConfig().getCallbacks().createClassLoader(oClassLoader.getParent(), oClassLoader);</span><br><span class="line"></span><br><span class="line">        // 将新的RePluginClassLoader写入mPackageInfo.mClassLoader，这里就是最重要的Hook点</span><br><span class="line">        ReflectUtils.writeField(oPackageInfo, &quot;mClassLoader&quot;, cl);</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到通过反射替换了系统的 ClassLoader 变成了 RePluginClassLoader,接下来我们看一下 RePluginClassLoader 的 loadClass方法。</p>
<p>RePluginClassLoader</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123;</span><br><span class="line">       //先用插件的classloader去加载类</span><br><span class="line">       Class&lt;?&gt; c = null;</span><br><span class="line">       c = PMF.loadClass(className, resolve);</span><br><span class="line">       if (c != null) &#123;</span><br><span class="line">           return c;</span><br><span class="line">       &#125;</span><br><span class="line">       //插件找不到用宿主的classloader去加载</span><br><span class="line">       try &#123;</span><br><span class="line">           c = mOrig.loadClass(className);</span><br><span class="line">           return c;</span><br><span class="line">       &#125; catch (Throwable e) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">       return super.loadClass(className, resolve);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在 RePluginClassLoader 的 loadClass 方法中先调用了 PMF.loadClass(className, resolve)。每个插件都会对应一个ClassLoader，这个方法会调用插件的 ClassLoader 也就是 PluginDexClassLoader，去加载插件的类。我们看一下 PluginDexClassLoader。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123;</span><br><span class="line">        // 插件自己的Class。从自己开始一直到BootClassLoader，采用正常的双亲委派模型流程，读到了就直接返回</span><br><span class="line">        Class&lt;?&gt; pc = null;</span><br><span class="line">        ClassNotFoundException cnfException = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            pc = super.loadClass(className, resolve);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            cnfException = e;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">		...</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>在 Android 中没有在 AndroidManifest.xml 文件中注册的 Activity 是无法启动的。那么在 RePlugin 是如何如何做到骗过系统的呢？那就是通过提前在宿主的 Manifest 注册好一些 Activity 也就是坑位的概念，当我们要启动一个插件的 Activity 的时候，会在宿主的 Manifest 中启动一个对应的坑位 Activity 。坑位的生成是在编译期通过 gradle 插件实现的。</p>
<p>接下来我们就以此为基础把 RePlugin 精简为一个小的插件化框架，我们目前只实现 Activity 的加载。<br>我们实现插件化的套路就是</p>
<ul>
<li>Hook 系统的 ClassLoader，替换成我们的 HostClassLoader</li>
<li>加载 Activity 类时先用插件的 ClassLoader 去加载，如果找不到再用宿主的 ClassLoader 去加载。</li>
<li>在 AndroidManifest.xml 文件中注册坑位</li>
<li>替换插件的资源路径</li>
</ul>
<p>首先定义 HostClassLoader 和 PluginClassLoder</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class HostClassLoader extends PathClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    public static Resources mPkgResources;</span><br><span class="line">    public static PluginContext mPkgContext;</span><br><span class="line">    private final ClassLoader mOrig;</span><br><span class="line">    static PluginClassLoader dexClassLoader;</span><br><span class="line"></span><br><span class="line">    public HostClassLoader(ClassLoader origin, ClassLoader parent) &#123;</span><br><span class="line">        super(&quot;&quot;, &quot;&quot;, parent);</span><br><span class="line">        mOrig = origin;</span><br><span class="line"></span><br><span class="line">        String path = Environment.getExternalStorageDirectory() + File.separator;</span><br><span class="line">        String filename = &quot;plugin-debug.apk&quot;;</span><br><span class="line"></span><br><span class="line">        File optimizedDirectoryFile = App.context.getCacheDir();</span><br><span class="line">        //初始化插件的ClassLoader，替换插件的资源路径。让插件能找到自己的资源文件。</span><br><span class="line">        dexClassLoader = new PluginClassLoader(path + filename, optimizedDirectoryFile.getAbsolutePath(),</span><br><span class="line">                null, this.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">        PackageManager pm = App.context.getPackageManager();</span><br><span class="line">        PackageInfo mPackageInfo = pm.getPackageArchiveInfo(path + filename,</span><br><span class="line">                PackageManager.GET_ACTIVITIES | PackageManager.GET_SERVICES | PackageManager.GET_PROVIDERS | PackageManager.GET_RECEIVERS | PackageManager.GET_META_DATA);</span><br><span class="line">        mPackageInfo.applicationInfo.sourceDir = path + filename;</span><br><span class="line">        mPackageInfo.applicationInfo.publicSourceDir = path + filename;</span><br><span class="line">        try &#123;</span><br><span class="line">            mPkgResources = pm.getResourcesForApplication(mPackageInfo.applicationInfo);</span><br><span class="line">        &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object getContext(Activity activity, Context context) &#123;</span><br><span class="line">        mPkgContext = new PluginContext(context, android.R.style.Theme, activity.getClass().getClassLoader(), mPkgResources);</span><br><span class="line">        return mPkgContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; c;</span><br><span class="line">        c = dexClassLoader.loadClass(className);</span><br><span class="line"></span><br><span class="line">        if (c != null) &#123;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            c = mOrig.loadClass(className);</span><br><span class="line">            return c;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.loadClass(className, resolve);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String className) throws ClassNotFoundException &#123;</span><br><span class="line">        return super.findClass(className);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class PluginClassLoader extends DexClassLoader &#123;</span><br><span class="line">    public PluginClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123;</span><br><span class="line">        super(dexPath, optimizedDirectory, librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123;</span><br><span class="line">    </span><br><span class="line">    //欺骗系统，当我们要启动com.host.sample.fake时，用插件的主页面替换掉，</span><br><span class="line">    //让系统去加载MainActivity这个类并返回，</span><br><span class="line">    //这样就相当于com.host.sample.fake这个坑位由MainActivity占领了。</span><br><span class="line">    </span><br><span class="line">        if (className.contains(&quot;com.host.sample.fake&quot;)) &#123;</span><br><span class="line">            className = &quot;com.plugin.sample.MainActivity&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; pc;</span><br><span class="line">        try &#123;</span><br><span class="line">            pc = super.loadClass(className, resolve);</span><br><span class="line">            if (pc != null) &#123;</span><br><span class="line">                return pc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hook 系统的 ClassLoader</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class App extends Application &#123;</span><br><span class="line"></span><br><span class="line">    public static Context context;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void attachBaseContext(Context base) &#123;</span><br><span class="line">        super.attachBaseContext(base);</span><br><span class="line">        context = base;</span><br><span class="line">        //在这里把系统的ClassLoader替换成HostClassLoader</span><br><span class="line">        patch(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean patch(Application application) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Context oBase = application.getBaseContext();</span><br><span class="line">            Object oPackageInfo = readField(oBase, &quot;mPackageInfo&quot;);</span><br><span class="line">            ClassLoader oClassLoader = (ClassLoader) readField(oPackageInfo, &quot;mClassLoader&quot;);</span><br><span class="line">            ClassLoader cl = new HostClassLoader(oClassLoader, oClassLoader.getParent());</span><br><span class="line">            writeField(oPackageInfo, &quot;mClassLoader&quot;, cl);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Manifest 中注册坑位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=&quot;com.host.sample.fake&quot; /&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">    Class&lt;?&gt; threadClazz = null;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void attachBaseContext(Context newBase) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            threadClazz = Class.forName(&quot;com.host.sample.HostClassLoader&quot;);</span><br><span class="line">            Method method = threadClazz.getMethod(&quot;getContext&quot;, Activity.class, Context.class);</span><br><span class="line">            newBase = (Context) method.invoke(null, this, newBase);</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        super.attachBaseContext(newBase);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后启动插件的 Activity</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">findViewById(R.id.open).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onClick(View v) &#123;</span><br><span class="line">               Intent intent = new Intent();</span><br><span class="line">               //这里真实启动的就是插件的Activity</span><br><span class="line">               intent.setComponent(new ComponentName(&quot;com.host.sample&quot;, &quot;com.host.sample.fake&quot;));</span><br><span class="line">               try &#123;</span><br><span class="line">                   MainActivity.this.startActivity(intent);</span><br><span class="line">               &#125; catch (Exception e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>


<p>希望通过这个小例子能让大家加深对 RePlugin 的理解，以上 demo 是在 Android 6.0 上跑的，不保证兼容性问题。</p>
<p><a href="https://github.com/77Y/HostSample" target="_blank" rel="noopener">源码地址：https://github.com/77Y/HostSample</a></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/projects_url">项目</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#360插件化框架-RePlugin-之-ClassLoader-Hook"><span class="toc-number">1.</span> <span class="toc-text">360插件化框架 RePlugin 之 ClassLoader Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言"><span class="toc-number">1.0.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是ClassLoader"><span class="toc-number">1.0.2.</span> <span class="toc-text">什么是ClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双亲委托模型"><span class="toc-number">1.0.3.</span> <span class="toc-text">双亲委托模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RePlugin是如何Hook-ClassLoader的"><span class="toc-number">1.0.4.</span> <span class="toc-text">RePlugin是如何Hook ClassLoader的</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2018/12/24/360%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%20RePlugin%20%E4%B9%8B%20ClassLoader%20Hook/" target="_blank" rel="noopener"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2018/12/24/360%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%20RePlugin%20%E4%B9%8B%20ClassLoader%20Hook/&text=360插件化框架 RePlugin 之 ClassLoader Hook" target="_blank" rel="noopener"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2018/12/24/360%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%20RePlugin%20%E4%B9%8B%20ClassLoader%20Hook/&title=360插件化框架 RePlugin 之 ClassLoader Hook" target="_blank" rel="noopener"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2018/12/24/360%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%20RePlugin%20%E4%B9%8B%20ClassLoader%20Hook/&is_video=false&description=360插件化框架 RePlugin 之 ClassLoader Hook" target="_blank" rel="noopener"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=360插件化框架 RePlugin 之 ClassLoader Hook&body=Check out this article: http://yoursite.com/2018/12/24/360%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%20RePlugin%20%E4%B9%8B%20ClassLoader%20Hook/" target="_blank" rel="noopener"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2018/12/24/360%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%20RePlugin%20%E4%B9%8B%20ClassLoader%20Hook/&title=360插件化框架 RePlugin 之 ClassLoader Hook" target="_blank" rel="noopener"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2018/12/24/360%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%20RePlugin%20%E4%B9%8B%20ClassLoader%20Hook/&title=360插件化框架 RePlugin 之 ClassLoader Hook" target="_blank" rel="noopener"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2018/12/24/360%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%20RePlugin%20%E4%B9%8B%20ClassLoader%20Hook/&title=360插件化框架 RePlugin 之 ClassLoader Hook" target="_blank" rel="noopener"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2018/12/24/360%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%20RePlugin%20%E4%B9%8B%20ClassLoader%20Hook/&title=360插件化框架 RePlugin 之 ClassLoader Hook" target="_blank" rel="noopener"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2018/12/24/360%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%20RePlugin%20%E4%B9%8B%20ClassLoader%20Hook/&name=360插件化框架 RePlugin 之 ClassLoader Hook&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 snow
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/projects_url">项目</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<!-- clipboard -->

  <script src="/lib/clipboard/clipboard.min.js"></script>
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight .code pre").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      target: function(trigger) {
        return trigger.nextElementSibling;
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>

<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
